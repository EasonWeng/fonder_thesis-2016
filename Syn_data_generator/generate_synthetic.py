# This module converts groundtruth data generated by blender into a flight log exploitable by our demo code

import numpy as np
import cv2
import cv
import matplotlib.pyplot as plt
import matplotlib as mlb
from numpy.linalg import inv

def q_mult(A):
    theta = np.arccos((np.trace(A)-1)*0.5)
    J = np.zeros((3,3))
    J = (A-A.transpose())/(2*np.sin(theta))
    v = np.zeros((1,3))
    v[0,0] = -J[1,2]
    v[0,1] = J[0,2]
    v[0,2] = -J[0,1]
    return theta*v

# Prepare quaternion for Hamilton product    
def q2mat(q):
    mat = np.eye(4)
    mat *= q[0,3]
    
    mat[3,2] = q[0,0]
    mat[0,1] = q[0,0]
    mat[1,0] = -q[0,0]
    mat[2,3] = -q[0,0]
    
    mat[0,2] = q[0,1]
    mat[1,3] = q[0,1]
    mat[2,0] = -q[0,1]
    mat[3,1] = -q[0,1]
    
    mat[0,3] = q[0,2]
    mat[2,1] = q[0,2]
    mat[1,2] = -q[0,2]
    mat[3,0] = -q[0,2]
    
    return mat

# Performs mean of input data over a centered window with given size
def window_mean(mat, win_size):
    end = mat.shape[0]
    res = np.zeros(mat.shape)
    
    for offset in range(-win_size,win_size+1):
        res[win_size:end-win_size,: ] += mat[win_size+offset:end-win_size+offset,:]
    
    res[win_size:end-win_size, :] = res[win_size:end-win_size, :]/(2*win_size+1)
    res[0:win_size,:] = mat[0:win_size,:]
    res[end-win_size:end,:] = mat[end-win_size:end,:]
    return res
    

def main():
    import sys
    csv = np.genfromtxt ("syn_groundtruth.csv", delimiter="\t")
    
    x = 1
    y = csv.shape[0]
    
    values = np.zeros((y/2, 13));
    freq = 200
    q1=np.zeros((1,4));
    q2=np.zeros((1,4));
    ind_off = 0
    
    tmp = np.zeros((y-1-x,3))
    tmp2 = np.zeros((y-1-x,3))
    
    for nbre in range(x,(y)-1):
        alpha = 0.01;
        i = nbre-x;
        tmp2[y-2-i-x,:] =  (1-alpha)*csv[y-i-1, 6:9] + alpha*csv[y-i-2, 6:9]
        tmp[nbre-x,:] = (1-alpha)*csv[nbre-1, 6:9] + alpha*csv[nbre, 6:9]        
        
    csv[x:y-1,6:9]=(tmp2[:,:]+tmp[:,:])*0.5
    
    # initialize biases
    biasa = np.zeros((1,3));
    biasa[0,0] = -0.3;
    biasa[0,1] = -0.4;
    biasa[0,2] = 0.02;
    
    bias = np.zeros((1,3));
    bias[0,0] = 0.03;
    bias[0,1] = 0.004;
    bias[0,2] = 0.08;
    
    # simulate IMU measurements and divide the sampling frequency by 2
    for nbre in range(x,(y/2)-1):
        i = nbre-x;
        j = nbre;
        rot = np.zeros((1,9));
        rot[0,:] = csv[2*j-1,13:22]
        rot = np.reshape(rot, (3,3))
        
        #generate accelerations
        tmp = (csv[2*j+1, 6:9]-2*csv[2*j, 6:9]+csv[2*j-1, 6:9])*freq*freq;
        values[i,0:3] = tmp;
        g = np.zeros((3,1))
        g[2] = 9.81
        g[:,0] += values[i,0:3].transpose()
        g[:] = np.dot(rot.transpose(), g)
        values[i,0:3] = g.transpose()

        quatInit = np.zeros((1,4))
        quatInit[0,:] = csv[2*j-1,9:13]
        
        initRot = q2mat(quatInit)
        initRot = inv(initRot)
        
        # estimate angular velocity
        quatDiff = np.zeros((1,4))
        quatDiff[0,0:4] = csv[2*j+1,9:13] - csv[2*j-1,9:13];
        
        tmp2 = q2mat(quatDiff*2)
        tmp3 = np.dot(tmp2,initRot)
        tmp3 *= 0.5*freq
        
        # take care of issues occuring for rotations around 180 deg
        for vi in range(0,3): 
            if i>0 and (values[i-1, 3+vi]* tmp3[0,1+vi])<-0.01:
                values[i, 3+vi]=-tmp3[0,1+vi]
            else:
                values[i, 3+vi] = tmp3[0,1+vi]        
               
        values[i, 6:9] = csv[2*j,6:9]-csv[2,6:9] #store groundtruth pose by initalizing the drone position to (0,0,0)
        values[i, 9:13] = csv[2*j,9:13]        
        
        #generate biases 
        bias += np.random.normal(0.0,0.00000001, (1, 3))
        values[i, 3:6] += bias[0,0:3];
        
        biasa+= np.random.normal(0.0,0.00000001, (1, 3))
        values[i, 0:3] += biasa[0,0:3];
        
    
    # add noise
    values[:, 0:3] = window_mean(values[:, 0:3], 12)
    values[:,0:3] += np.random.normal(0.0,0.0035, (values.shape[0], 3))
    values[:,3:6] += np.random.normal(0.0,0.0035, (values.shape[0], 3))
    
    values = np.float32(values)
    print(np.mean(values,0))
    
    opencvmat = cv.fromarray(values)
    cv.Save("data.yml", opencvmat)
    
# Grountdtruth features ********************************************************************
    
    csvPos = np.genfromtxt ("featurePos.csv", delimiter="\t")
    values = np.zeros((csvPos.shape[0], 3));
    print(csv[2,6:9])
    print(csvPos[0,:])
    
    for i in range(0,csvPos.shape[0]-1):
        values[i,:] = csvPos[i,:]-csv[0,6:9]
    
    values = np.float32(values)    
    opencvmat = cv.fromarray(values)
    cv.Save("featurePos.yml", opencvmat)
    
    

if __name__ == '__main__':
    main()
